Ozon
1)
Нужно написать простую библиотеку in-memory cache.
Реализация должна удовлетворять интерфейсу:
type Cache interface {
    Set(k, v string)
    Get(k string) (v string, ok bool)
}

Доп: Реализовать кэш с партициями

2)
Рассказать, как устроен LRU cache

Кеш имеет фиксированный максимальный размер. 
Если после вставки нового элемента превышается максимально допустимый размер кеша, из него нужно удалить самый старый элемент.

Пример:
cache = new LRU(capacity=2)

cache.put(A, 1); // cache is {A=1}
cache.put(B, 2); // cache is {A=1, B=2}
cache.get(A);    // return 1
cache.put(C, 3); // {A=1, C=3}, element B=2 was evicted
cache.get(B);    // returns -1 (not found)
cache.put(D, 4); // {D=4, C=3}
cache.get(A);    // return -1 (not found)
cache.get(C);    // return 3
cache.get(D);    // return 4
3)
package main

func main() {
  var urls = []string{
    "http://ozon.ru",
    "https://ozon.ru",
    "http://google.com",
    "http://somesite.com",
    "http://non-existent.domain.tld",
    "https://ya.ru",
    "http://ya.ru",
    "http://ёёёё",
  }
}
1. Поочередно выполнит http запросы по предложенному списку ссылок
- в случае получения http-кода ответа на запрос "200 OK" печатаем на экране "адрес url - ok"
- в случае получения http-кода ответа на запрос отличного от "200 OK" либо в случае ошибки печатаем на экране "адрес url - not ok"

2. Модифицируйте программу таким образом, чтобы использовались каналы для коммуникации основного потока с горутинами. Пример:
Запросы по списку выполняются в горутинах.
Печать результатов на экран происходит в основном потоке

3. Модифицируйте программу таким образом, чтобы нигде не использовалась длина слайса урлов. Считайте, что урлы приходят из внешнего источника. Сколько их будет заранее - неизвестно. Предложите идиоматичный вариант, как ваша программа будет узнавать об окончании списка и передавать сигнал об окончании действий далее.

4. Модифицируйте программу таким образом, что бы при получении 2 первых ответов с "200 OK" остальные запросы штатно прерывались.

4)Есть запрос на сервис и есть ответ, между этими двумя действиями мы сладываем в аналитику товары которые заказали (например для подсчета популярности товаров). Сервис аналитики переодически работает медленно или вовсе таймаутит, и мы не успеваем ответить, теряем заказы.

Что делать, что бы перестать терять заказы, и деньги соответсвенно?


+-------+         +---------------+    +-------------------+
| User  |         | OrderService  |    | AnalyticsService  |
+-------+         +---------------+    +-------------------+
    |                     |                      |
    | CreateOrder         |                      |
    |-------------------->|                      |
    |                     |                      |
    |                     | TrackOrder           |
    |                     |--------------------->|
    |                     |                      |
    |                     |                      | Too long action
    |                     |                      |----------------
    |                     |                      |               |
    |                     |                      |<---------------
    |                     |                      |
    |                     |                      |
    |                     |<---------------------|
    |                     |                      |
    |                     |                      |
    |<--------------------|                      |
    |                     |                      |

5)Есть 3 сущности - пользователь, чат, сообщение

- У пользователя есть имя и дата регистрации
- У чата есть название и дата создания
- У сообщения есть текст, автор и дата создания
- Пользователь может состоять в нескольких чатах одновременно
Сообщение обязательно принадлежит чату, сообщение не может принадлежать более чем 1 чату одновременно
Нужно описать предметную область в виде таблиц

Доп: Выбрать все чаты пользователя Вася в формате (chat_id,chat_name)