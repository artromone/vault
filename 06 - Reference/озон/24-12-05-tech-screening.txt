
// Требуется реализовать функцию uniqRandn, которая генерирует слайс длины n уникальных, рандомных чисел.

package main

import (
	"fmt"
)

func main() {
	fmt.Println(uniqRandn(10))
}

// генерирует слайс длины n уникальных, рандомных чисел
func uniqRandn(n int) []int {
    return nil
}

---

Дана таблица "orders":

+-----+-----------+------------------------+--------------+
|  id |  user_id  |             created_at |  price_total |
+-----+-----------+------------------------+--------------+
|   1 |       111 |    2024-01-01 10:00:00 |        2 000 |
|   2 |       222 |    2024-01-02 10:00:00 |          100 |
|   3 |       111 |    2024-04-01 10:00:00 |       20 000 |
|   4 |       222 |    2024-05-01 10:00:00 |        5 000 |
|   5 |       333 |    2024-05-02 10:00:00 |       10 000 |
+-----+-----------+------------------------+--------------+


Напишите SQL-запрос, который вернёт количество заказов по каждому пользователю с price_total больше или равным 1000 в таком виде отсортированному по количеству заказов в обратном порядке:


+----------+-------------+
|  user_id | order_count |
+----------+-------------+
|      111 |           2 |
|      222 |           1 |
|      333 |           1 |
+----------+-------------+

---

Что такое каналы?
Какие каналы бывают?
Что будет если из закрытого канала читать?
Что будет если из закрытого буферизированный канала читать и его буфер еще не пустой?
Что будет если закрыть канал повторно?
Как можно читать из нескольких каналов?
Если мы читаем из нескольких каналов можно ли сделать так чтобы мы не ждали появится ли данные в этих каналах, а просто если этих данных нет то дальше выполнять код?

Расскажи про примитивы синхронизации
WaitGroup. Расскажи про них

Как внутри выглядят каналы расскажи кратко?
Как называется структура данных с помощью которой реализован буффер у каналов?
В чем приемущество этой структуры данных?

--- 

package main

import "fmt"

func main() {
	nums := []int{1, 2, 3}

	addNum(nums[0:2])
	fmt.Println(nums) // ?

	addNums(nums[0:2])
	fmt.Println(nums) // ?
}

func addNum(nums []int) {
	nums = append(nums, 4)
}

func addNums(nums []int) {
	nums = append(nums, 5, 6)
}

---

// Что выведет программа?
// Почему именно такой вывод?


package main

import "fmt"

func main() {
	m := map[string]int{"a": 1, "b": 2, "c": 3}

	for a, b := range m {
		fmt.Println(a, b)
	}
}

---

/// Что будет?

package main

func main() {
	s := "test"
	println(s[0]) // ?
	s[0] = 'R'
	println(s) // ?
}

--- 

/// Напиши решение чтобы изменился первий бит
/// Используй byte

package main

func main() {
	s := "test"
	println(s[0]) // ?
	s[0] = 'R'
	println(s) // ?
}