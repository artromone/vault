#prog/golang  #todo

Безопасный и эффективный доступ к карте из нескольких горутин

Go 1.9

Нужная когда высокая конкуренция на доступ к данным
Полезно, когда чтение чаще, чем запись

- `Store(key, value)`: Сохраняет значение по указанному ключу.
- `Load(key)`: Загружает значение по указанному ключу и возвращает его вместе с булевым значением, указывающим на наличие ключа.
- `LoadOrStore(key, value)`: Загружает значение по ключу или сохраняет его, если ключ отсутствует.
- `Delete(key)`: Удаляет значение по указанному ключу.
- `Range(f func(key, value interface{}) bool)`: Итерирует по всем элементам карты и применяет переданную функцию к каждому элементу.

Оптимизация: 
> Одно хранилище для грязных данных, требующих блокировки, другое для чистых, которые доступны без блокировок. Когда очень много операций записи, автоматически переключение на использование блокировок для производительности

- `sync.Map` хранит две `map` внутри. `clean` и `dirty`
- Обращение к `clean` всегда происходит без лока
- Обращение к `dirty` требует лока
- Периодически `dirty` повышается до `clean`

Устойчивость к race condition
> Без гонок данных

почему нельзя просто закостылить свою, обернув мапу через mutex
- оптимизировано для случаев более частого чтения. атомарные операции для чтения
- упрощение кода
- автоматизация (переход от грязного к чистому)
- ленивая инициализация

Многоядерный процессор – sync.Map