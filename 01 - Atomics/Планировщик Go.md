#prog #prog/golang  

> Часть runtime, управляет выполнением горутин [[Горутины и каналы]], обеспечивает [[Конкурентность]] и [[Параллелизм]], эффективно распределяя ресурсы

Планировщик (для потоков ОС) требует переключения контекста
У Golang свой планировщик – **`m:n` планирование**: планирует выполнение `m` go-подпрограмм на `n` потоках ОС
Поскольку переключение контекста ядра не требуется, планирование go-подпрограмм намного дешевле, чем потоков

#### **Goroutine (G)**
- Легковесный поток выполнения, управляемая Go runtime (не потоками ОС)
- Занимает ~2 КБ памяти (может расти/уменьшаться динамически)
- Единица выполнения. Перемещается между очередями P.
#### **OS Thread (M)**
- "Машина" (machine) — поток операционной системы
- Выполняет горутины, каждый физически может выполнить одну горутину в любой момент времени
- Планировщик использует M для выполнения кода на физических ядрах CPU
- M (потоки ОС) выполняют N горутин через P (виртуальные процессоры)
- Если M блокируется (например, на системном вызове), runtime может создать новую M
#### **Processor (P)**
- Виртуальный "процессор", который связывает M и G
- У каждого P есть локальная очередь горутин (runqueue) и ссылка на текущую M
- Количество P по умолчанию равно [[GOMAXPROCS]] (обычно числу CPU ядер), определяет степень параллелизма (параллельно работающих горутин)

![[Планировщик Go-1727202330015.jpeg]]


##### Запуск горутины
- При запуске горутина перемещается в **локальную очередь** текущего P
- Если локальная очередь P заполнена (более 256 горутин), половина перемещается в **глобальную очередь**

##### **Work-Stealing (кража задач)**
Если у P закончились горутины в локальной очереди:
- Он проверяет **глобальную очередь**
- Если глобальная очередь пуста, P крадет половину горутин из очереди другого случайного P
Это обеспечивает балансировку нагрузки между ядрами CPU

##### **Системные вызовы и блокировки**
Если горутина выполняет блокирующий системный вызов (например, файловый I/O):
- P отсоединяется от текущего M и переходит к другой M (или создает новую)
- Когда системный вызов завершается, горутина возвращается в очередь P      
**Сетевые вызовы** (non-blocking):
- Используется асинхронный ввод-вывод через `epoll` (Linux)
- Горутина не блокирует M, что позволяет эффективно обрабатывать тысячи соединений

[[Многозадачность в Golang]]

##### Настройки:
[[GOMAXPROCS]]
**Debugging**:
- `GODEBUG=schedtrace=1000` — вывод информации о планировщике каждую секунду        
- `go tool trace` — визуализация работы горутин, потоков и процессоров
---

Очереди выполнения:
- Глобальная – Содержит все горутины, готовые к выполнению
- Локальная – Каждому P соответствует локальная очередь горутин, назначенных на выполнение

Принципы работы планировщика:
- Если одна из локальных очередей пуста, P может украсть горутину из другой локальной очереди для повышения эффективности использования ресурсов
- Переключение между горутинами быстрее, чем между контекстом ОС
- Решения о переключении контекста на основе определенных событий в коде (вызов функций)
- Недетерминированный


Есть планировщик, который создает несколько машин, которые управляют горутинами
Количество машин создаваемых равно количеству процессоров на компе
Планировщик умный, периодически устраивает вытеснение задач (задача отправляется в самый конец и начинает выполнять следующую)
Есть локальная и глобальная очередь у каждой машины, если недозагруженность, можем взять задачу у горутины, у которой высокая загрузка
Стилинг – забираем задачи у работающих горутин в момент создания машины