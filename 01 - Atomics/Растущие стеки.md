#prog/golang #prog/concurrency #/todo

Каждый поток ОС имеет блок памяти фикс размера (до **2 Мбайт**) для стека (для хранения локальных переменных вызовов функций)

Для go-подпрограмм 2 Мбайта могут быть слишком большими
Поэтому они начинают с 2 Кбайт и при необходимости растут до 1 Гбайта

1. **Начальный размер стека**: Когда горутина создается, ей выделяется небольшой стек (обычно 2 КБ)
2. **Рост стека**: Если горутине требуется больше памяти для выполнения (например, из-за глубокой рекурсии или большого количества локальных переменных), runtime Go автоматически увеличивает размер стека. Это происходит прозрачно для программиста
3. **Сжатие стека**: Если стек горутины становится слишком большим, но часть памяти больше не используется, runtime может уменьшить размер стека, чтобы освободить память

- **Эффективное использование памяти**: Поскольку стеки горутин начинаются с маленького размера и растут только при необходимости, это позволяет создавать большое количество горутин без значительных накладных расходов на память
- **Масштабируемость**: Go может легко поддерживать тысячи или даже миллионы горутин, что делает его идеальным для высоконагруженных backend-систем

#### Недостатки и нюансы
- **Накладные расходы на управление памятью**: Хотя растущие стеки эффективны, они все же требуют некоторого управления со стороны runtime, что может привести к небольшим накладным расходам
- **Фрагментация памяти**: В некоторых случаях, особенно при частом росте и сжатии стеков, может возникать фрагментация памяти, что может повлиять на производительность
