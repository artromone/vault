#prog #prog/golang #prog/golang/interface #/todo

> Операция, применимая к значению-интерфейсу

Синтаксис: `x.(T)` (`x` – выражение интерфейсного типа,  `T` – декларируемый тип)

### 1) Если декларируемый тип `T` – *конкретный тип*

...то декларация типов проверяет, идентичен ли динамический тип `х` типу `T`
>  Декларация типа для конкретного типа извлекает конкретное значение из своего операнда

```go
var w io.Writer
w = os.Stdout
f := w.(*os.File)      // Успешно: f == os.Stdout
с := w.(*bytes.Buffer) // Аварийная ситуация: интерфейс хранит *os.File, а не *bytes.Buffer
```

- если проверка успешна, результат декларации: динамическое значение `x` с типом `T`
- если проверка неуспешна, аварийная ситуация

### 2) Если декларируемый тип `T` – *тип интерфейса*

Проверка, идентичен ли динамический тип `x` интерфейсу `T`
> Декларация типа для типа интерфейса изменяет тип выражения, делая доступным иной (обычно больший) набор методов, но сохраняет динамический тип и значения компонентов внутри зна­чения интерфейса

- если проверка успешна, динамическое значение не извлекается
	- значение результата – значение интерфейса с тем же типом и значениями компонентов
	- сам результат – тип интерфейса `T`
- если проверка неуспешна, аварийная ситуация

```go
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // Успех: *os.File имеет методы Read и Write
w = new(ByteCounter)
rw = w.(io.ReadWriter) // Аварийная ситуация: *ByteCounter не имеет метода Read
```


Как убрать аварийную ситуацию:
```go
var w io.Writer = os.Stdout
f, ok := w.(*os.File)      // Успех: ok, f == os.Stdout
b, ok := w.(*bytes.Buffer) // Неудача: !ok, b == nil
```
