Допустим, у нас есть большой список размером n. При вызове функция merge_sort выполняет следующие операции:
- разбивает список на половины, что **не зависит от размера списка O(1)**
- вызывает функцию merge ([[Временная сложность merge]]), которая имеет **сложность O(n)**)
- делает два рекурсивных вызова merge_sort, которые **не учитываются**

[[Временная сложность алгоритма]] каждого шага разбиения составляет O(n) (потому что в 2 раза меньше элементов и подмножеств в 2 раза больше, 2/2=1)

Временная сложность сортировки слиянием, следовательно, составляет x • O(n), где x — это количество шагов разбиения, необходимых для полного выполнения алгоритма

Как вычислить x? Мы знаем, что рекурсивные функции заканчивают вызывать себя, как только достигают своего базового случая. Наш базовый случай — это одноэлементный список. Мы также увидели, что шаг разбиения x работает на списках из n/2^x элементов. Потому:

![[Pasted image 20230221181012.png]]

Временная сложность сортировки слиянием, следовательно, составляет log2 n × O(n) = O(n logn).